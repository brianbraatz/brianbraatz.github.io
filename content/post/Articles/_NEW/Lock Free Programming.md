---
title: 
description: 
slug: 
date: 2023-04-06
image: post/Articles/IMAGES/21.jpg
categories: 
tags:
  - Cheatsheet
  - SQL
  - PostgresSql
  - MySql
  - SqlLite
weight: 30
draft: true
lastmod: 2025-01-31T14:45:58.211Z
---
## Chat history

\[https://chatgpt.com/c/679cc211-32f8-8008-be62-ce5e057461e2

ChatGPT

ChatGPT

]\(https://chatgpt.com/ "ChatGPT")

\[

Explore GPTs]\(https://chatgpt.com/gpts)

### Today

1. \[

   Why Love SQLite

   ]\(https://chatgpt.com/c/679cae0e-6fb8-8008-9c57-bdcb1e993599)

2. \[

   SQL Syntax Comparison

   ]\(https://chatgpt.com/c/679cac39-9e40-8008-a348-663da0047b74)

3. \[

   Horseradish History and Recipes

   ]\(https://chatgpt.com/c/679cd575-8b04-8008-8224-c67a485e02a1)

4. \[

   F# Language Overview

   ]\(https://chatgpt.com/c/679cd2db-e5cc-8008-9de3-b57b73829dbf)

5. \[

   Stored Procedures vs Queries

   ]\(https://chatgpt.com/c/679cd1c2-6340-8008-b7b6-73dc022f0433)

6. \[

   Stored Procedures in SQL

   ]\(https://chatgpt.com/c/679cd179-0210-8008-bc3b-87cd6fc73763)

7. \[

   Indexing and Views Best Practices

   ]\(https://chatgpt.com/c/679cd118-f7d8-8008-803d-9741f7a9e879)

8. \[

   Subselects vs Temp Tables

   ]\(https://chatgpt.com/c/679cd0b6-23e4-8008-ad93-8c22123bb212)

9. \[

   SPs vs UDFs Comparison

   ]\(https://chatgpt.com/c/679cd01b-c070-8008-84bf-4992704f35c1)

10. \[

    Linq Cheat Sheet

    ]\(https://chatgpt.com/c/679ccf18-fbb4-8008-ae45-459936340a6a)

11. \[

    C# Scripting Languages Overview

    ]\(https://chatgpt.com/c/679cceb9-93fc-8008-8ddd-da8c0e5c6a40)

12. \[

    GUI Scripting in Multiple Languages

    ]\(https://chatgpt.com/c/679cce3c-3fe0-8008-8a5f-38e4ea311a29)

13. \[

    DB Context Factory Examples

    ]\(https://chatgpt.com/c/679ccd69-4998-8008-ae7b-be1647fbf1ce)

14. \[

    Scripting GUIs in C#

    ]\(https://chatgpt.com/c/679cccf7-b5bc-8008-9a11-c4b10264b526)

15. \[

    Async Await and Threading

    ]\(https://chatgpt.com/c/679ccb94-8304-8008-aa89-47cdfa14a4ed)

16. \[

    Control Template vs Style Template

    ]\(https://chatgpt.com/c/679ccaed-54e0-8008-a6e7-ecbb600b1c11)

17. \[

    SOLID Principles in Python

    ]\(https://chatgpt.com/c/679ccaa1-68f8-8008-8af1-9db79df3b75f)

18. \[

    MVVM History and Motivation

    ]\(https://chatgpt.com/c/679cca6f-f9c0-8008-a1d2-50a2849deac6)

19. \[

    WPF Square Mover

    ]\(https://chatgpt.com/c/679cc9ec-cbe8-8008-9b16-035779729f6f)

20. \[

    Personal Proxy with GAE

    ]\(https://chatgpt.com/c/679cc8e7-0038-8008-84d5-591f373c8296)

21. \[

    Google App Engine Tutorial

    ]\(https://chatgpt.com/c/679cc7c0-e460-8008-bfc1-39bf12229590)

22. \[

    Database Performance Comparison

    ]\(https://chatgpt.com/c/679cc75a-3edc-8008-b3ba-0e63cd38395f)

23. \[

    Scaling Docker and Kubernetes Challenges

    ]\(https://chatgpt.com/c/679cc6cb-a244-8008-8abf-2c1ab91cb2da)

24. \[

    AWS vs Google vs Azure

    ]\(https://chatgpt.com/c/679cc638-f120-8008-a9fe-7badb8a3c75a)

25. \[

    REST vs MQTT Comparison

    ]\(https://chatgpt.com/c/679cc5a6-5370-8008-a35d-125e8e2cab72)

26. \[

    Bootstrap Overview and Techniques

    ]\(https://chatgpt.com/c/679cc4b1-50f0-8008-bb4c-c5d28cf4d908)

27. \[

    EF Query Syntaxes

    ]\(https://chatgpt.com/c/679cc445-a5b4-8008-9014-624c17d252e1)

28. \[

    EF Performance Optimization

    ]\(https://chatgpt.com/c/679cc3ef-5474-8008-b642-51be6b0dd2f6)

29. \[

    C# Performance Optimization Tips

    ]\(https://chatgpt.com/c/679cc3b2-540c-8008-a7c5-6d82947c25df)

30. \[

    Python Performance Optimization

    ]\(https://chatgpt.com/c/679cc308-8e74-8008-91de-f3ae53ca6569)

31. \[

    Value of swap function

    ]\(https://chatgpt.com/c/679cc2db-4120-8008-9ee2-7a0785bfbc1f)

32. \[

    Lock-Free Programming Insights

    ]\(https://chatgpt.com/c/679cc211-32f8-8008-be62-ce5e057461e2)

33. \[

    SQL Query Plan Optimization

    ]\(https://chatgpt.com/c/679cc148-031c-8008-8a56-911c96f96e50)

34. \[

    DBContextFactory CLI Typescript

    ]\(https://chatgpt.com/c/679cc05f-dbe4-8008-b4cb-7c5647c6d282)

35. \[

    Go DB Context Factory

    ]\(https://chatgpt.com/c/679cbf70-ffc0-8008-ab85-aac0d365a473)

36. \[

    Python DB Context Factory

    ]\(https://chatgpt.com/c/679cbef8-27b8-8008-8a67-e8dd3f55f895)

37. \[

    EF Core SQLite Example

    ]\(https://chatgpt.com/c/679cb212-d194-8008-97e9-c3ea51544a85)

38. \[

    Bad SQL Practices Guide

    ]\(https://chatgpt.com/c/679cafb2-eb60-8008-a7f7-34131af6a916)

### Yesterday

1. \[

   25 Weird CSS Effects

   ]\(https://chatgpt.com/c/679c0785-e3b0-8008-9fe9-0a9461e18e50)

2. \[

   Python WebSocket Server

   ]\(https://chatgpt.com/c/679be3f0-4ee4-8008-998b-ae6c981d52b3)

3. \[

   Force load insecure site

   ]\(https://chatgpt.com/c/679bb6d6-3f14-8008-b39e-de4a9ec9e299)

4. \[

   Python Web Frameworks Comparison

   ]\(https://chatgpt.com/c/679b7b4d-47b8-8008-8616-a79962e78121)

### Previous 7 Days

1. \[

   C++ Profiling Template Metaprogramming

   ]\(https://chatgpt.com/c/679a8133-6e08-8008-84c5-cfdcd2006502)

2. \[

   AWS vs Azure vs GCP

   ]\(https://chatgpt.com/c/67996204-8138-8008-a8b0-f171d0b24210)

3. \[

   Image Upscaling Request

   ]\(https://chatgpt.com/c/679a48a3-63a0-8008-8051-048e28659f43)

4. \[

   Languages with Bag Collection

   ]\(https://chatgpt.com/c/679a1935-c49c-8008-af33-9164b1390ae3)

5. \[

   HIPAA Compliance in Cloud

   ]\(https://chatgpt.com/c/67997309-f7a0-8008-ad9c-5bf91ce5519d)

6. \[

   CSV Engineer Roles

   ]\(https://chatgpt.com/c/6799661c-8f54-8008-bd46-768e43f2c844)

7. \[

   Types of Agile Methods

   ]\(https://chatgpt.com/c/679944a3-feb8-8008-be85-1751d84fb9cd)

8. \[

   Cover Image Request

   ]\(https://chatgpt.com/c/6798cb34-01c4-8008-ab93-659c33a31935)

9. \[

   Display full path robocopy

   ]\(https://chatgpt.com/c/6798bfc5-27d8-8008-8bef-e61cd6bafd66)

10. \[

    Blog Banner Request

    ]\(https://chatgpt.com/c/67983de8-185c-8008-99ae-099991e81606)

11. \[

    PDF to Markdown Images

    ]\(https://chatgpt.com/c/67982ddf-6180-8008-a1a0-28747beb73be)

12. \[

    Embedding PDFs in Hugo

    ]\(https://chatgpt.com/c/6798259e-108c-8008-ae2a-e805d649498d)

13. \[

    Reduce text size HTML

    ]\(https://chatgpt.com/c/6797ddd3-0a58-8008-9f97-ff53bb5076a1)

14. \[

    Aligning Links in LaTeX

    ]\(https://chatgpt.com/c/6797cb00-6adc-8008-8f6c-c6de975cf9f8)

15. \[

    HTML List Conversion

    ]\(https://chatgpt.com/c/6797a4d0-140c-8008-912e-f3ea97f960b7)

16. \[

    Markdown comment techniques

    ]\(https://chatgpt.com/c/67977924-a5e4-8008-90b9-e204112ec302)

17. \[

    Obsidian to Hugo Links

    ]\(https://chatgpt.com/c/6797720f-a75c-8008-b52f-00be909d07f4)

18. \[

    Check Pandoc Installation

    ]\(https://chatgpt.com/c/67975b0b-c348-8008-bf8d-b2b41659ddd7)

19. \[

    Publish Hugo Site FTP

    ]\(https://chatgpt.com/c/67941d6b-d1f4-8008-a2b2-3b7f503fc752)

20. \[

    Fix Obsidian Links

    ]\(https://chatgpt.com/c/6796de48-da14-8008-9786-53a967d86710)

21. \[

    Show images in Hugo

    ]\(https://chatgpt.com/c/6796d755-c3ec-8008-ba2d-aed274dd436a)

22. \[

    Batch file not executing

    ]\(https://chatgpt.com/c/6796d457-46a8-8008-a19d-e762022f17fb)

23. \[

    Delete Git History

    ]\(https://chatgpt.com/c/6796c4dc-9f60-8008-8e55-8bf9f114c4a4)

24. \[

    Commenting in go.mod

    ]\(https://chatgpt.com/c/6796b6a3-fdd0-8008-8572-59e2f6299f25)

25. \[

    Obsidian File Embedding

    ]\(https://chatgpt.com/c/67967a67-a688-8008-9e17-deb933a1d0c2)

26. \[

    List Python Packages

    ]\(https://chatgpt.com/c/679586c3-c074-8008-b923-d4b8e8c0d224)

27. \[

    Go Bubble Sort Program

    ]\(https://chatgpt.com/c/67967f8c-806c-8008-a908-1e968d889693)

28. \[

    GitHub Pages SQL Download

    ]\(https://chatgpt.com/c/6795a1bb-2b8c-8008-a4dc-7424eac90985)

29. \[

    Remove brightness widget Windows 11

    ]\(https://chatgpt.com/c/679673b0-94c4-8008-8205-86552c0434b1)

30. \[

    Custom Domain on GitHub

    ]\(https://chatgpt.com/c/67963249-5a64-8008-ad35-2bb29cf04218)

31. \[

    Hugo Obsidian GitHub Setup

    ]\(https://chatgpt.com/c/67962ffd-8120-8008-b892-8d12727e00af)

32. \[

    Submodule Subdirectory Workarounds

    ]\(https://chatgpt.com/c/67962e22-6754-8008-af30-e4c18e32e216)

33. \[

    Obsidian Vaults and Glass

    ]\(https://chatgpt.com/c/67962a2f-40b0-8008-a94d-381c26b12424)

34. \[

    Running JS in Obsidian

    ]\(https://chatgpt.com/c/67962736-d1b8-8008-85dd-f34fd3d56f04)

35. \[

    Embed HTML in Obsidian

    ]\(https://chatgpt.com/c/67961fbe-3618-8008-b0d4-6056be2fa1f6)

36. \[

    GitHub Project Uses

    ]\(https://chatgpt.com/c/679531cd-4b30-8008-bfb2-6616c0020a88)

37. \[

    Add Titles to MD Files

    ]\(https://chatgpt.com/c/67950170-64c4-8008-9819-cdc3469eee23)

38. \[

    Add title front matter

    ]\(https://chatgpt.com/c/6794f79a-30c4-8008-b935-3d13c5339033)

39. \[

    Creating Interesting Images

    ]\(https://chatgpt.com/c/6794ec34-5e10-8008-ba14-df2fa0ba8e61)

40. \[

    Obsidian Quartz vs Hugo

    ]\(https://chatgpt.com/c/6794d603-ca80-8008-9b02-17efc3492d8c)

41. \[

    Git Submodule vs Subtree

    ]\(https://chatgpt.com/c/6794cd48-e4c0-8008-94f6-22997b7ed244)

42. \[

    GitHub Pages vs Hostinger

    ]\(https://chatgpt.com/c/6794ca32-c744-8008-ac26-63efbc2a0bb2)

Upgrade planMore access to the best models

ChatGPT

Share

![User](https://lh3.googleusercontent.com/a-/AFdZucrLS9igzyAqqO90JjCO57Sa5XCSFZ9gPud8ZWD21g=s96-c)

##### You said:

Write an article explaining lock free programming. Reference the writings of Andrei Alexandrescu.

###### ChatGPT said:

ChatGPT

**Understanding Lock-Free Programming: A Deep Dive Inspired by Andrei Alexandrescu's Writings**

In modern systems programming, managing concurrency is one of the most critical challenges. Traditional locking mechanisms such as mutexes and semaphores have served us well, but they come with certain drawbacks, such as performance bottlenecks, deadlocks, and increased complexity. In the quest for more efficient solutions, lock-free programming has emerged as a powerful paradigm. This article explores lock-free programming, with insights drawn from Andrei Alexandrescu's seminal work on the topic.

### What is Lock-Free Programming?

Lock-free programming refers to a set of techniques that allow threads to operate on shared data without using locks or other synchronization primitives that could block execution. Instead of waiting for a lock to be released, threads perform operations in a way that ensures that at least one thread will succeed in making progress, even in the presence of contention. The goal is to avoid the performance bottlenecks and latency associated with traditional locking mechanisms.

A key distinction here is that lock-free programming does not necessarily mean "no locking at all." Rather, it means that the program is designed such that, under normal conditions, threads can avoid being blocked by locks, relying instead on atomic operations and careful design.

### Andrei Alexandrescu's Contribution to Lock-Free Programming

Andrei Alexandrescu, a well-known C++ expert and author of *"Modern C++ Design"* and *"C++ Coding Standards"*, has made significant contributions to the development and understanding of lock-free programming. His work emphasizes the importance of writing efficient, scalable, and deadlock-free code.

In his influential paper, *"Lock-Free Data Structures"*, Alexandrescu elaborates on the fundamentals of lock-free programming, explaining the key concepts and techniques that make it possible. He identifies several challenges involved in designing lock-free systems, such as managing shared memory, handling atomic operations, and ensuring that the system behaves correctly even under high contention.

### Key Concepts in Lock-Free Programming

1. **Atomic Operations**: Atomic operations are the building blocks of lock-free programming. These are operations that execute without interruption, ensuring that they either complete entirely or not at all. The most common atomic operations include compare-and-swap (CAS) and fetch-and-add, which allow threads to modify data safely in a multi-threaded environment.

   Andrei Alexandrescu underscores the importance of atomicity in lock-free designs. By ensuring that critical updates to shared data are done atomically, the need for traditional locks is eliminated.

2. **Memory Ordering**: In multi-core processors, the order in which memory operations are executed can vary. This can lead to subtle bugs where a thread reads stale or inconsistent data. Memory barriers and fences are used to control the order of memory operations, ensuring that updates to shared variables are seen by all threads in a consistent way.

   Alexandrescu discusses how lock-free algorithms must take memory ordering into account to ensure correctness. By using atomic operations in conjunction with memory fences, lock-free algorithms avoid race conditions and data corruption.

3. **Non-blocking Algorithms**: In a lock-free system, threads should not block each other or wait indefinitely for a resource. Alexandrescu emphasizes the use of non-blocking algorithms, which allow threads to operate independently without requiring synchronization through locks. These algorithms are designed to guarantee that some thread will always make progress, even if others are stalled.

4. **CAS-based Algorithms**: One of the most widely used methods in lock-free programming is the compare-and-swap (CAS) algorithm. CAS works by atomically comparing a value in memory with an expected value, and if they match, swapping it with a new value. This operation is the foundation for many lock-free data structures such as linked lists, stacks, and queues.

   Alexandrescu highlights the power of CAS in his writings, showing how it can be used to implement complex data structures that are safe in concurrent environments.

### Practical Applications of Lock-Free Programming

Lock-free programming is not just a theoretical concept; it has real-world applications in systems where performance and scalability are paramount. Here are a few areas where lock-free techniques shine:

1. **High-performance Databases**: In databases, especially those designed for high-throughput applications, locking mechanisms can create contention, slowing down performance. Lock-free data structures allow for faster updates and retrievals, as threads do not have to wait for locks to be released.

2. **Real-time Systems**: In real-time applications, it is critical to avoid blocking operations that could introduce delays. Lock-free programming ensures that tasks are completed within strict time constraints without waiting on other threads.

3. **Multithreaded Game Engines**: Game engines often require real-time, high-performance, and highly concurrent systems. Lock-free algorithms can be used in areas like physics simulations and AI systems, where threads need to update shared data structures without delays.

4. **Operating Systems**: Operating systems manage multiple threads and processes that need to interact with shared resources. Lock-free programming is increasingly used in OS kernels to improve the efficiency of scheduling, memory management, and inter-thread communication.

### Benefits of Lock-Free Programming

* **Scalability**: Lock-free algorithms tend to scale better as the number of processors increases because they avoid the contention introduced by locks.
* **Reduced Latency**: By eliminating blocking operations, lock-free programming can reduce the time spent waiting for resources, leading to lower latency and faster execution.
* **Avoidance of Deadlocks**: Since there are no locks, the possibility of deadlocks is eliminated. This simplifies the design and maintenance of complex systems.
* **Fault Tolerance**: Lock-free systems can often continue operating even in the presence of failures, as threads are not blocked indefinitely.

### Challenges and Considerations

While lock-free programming offers many benefits, it is not without challenges. Designing lock-free algorithms can be complex and requires a deep understanding of concurrency, memory models, and atomic operations. Additionally, incorrect use of atomic operations can lead to subtle bugs such as race conditions or memory corruption. Developers must also be cautious of memory reclamation and garbage collection in lock-free systems, as improper handling can lead to memory leaks or dangling pointers.

### Conclusion

Lock-free programming is an advanced but powerful technique for writing concurrent programs that are scalable, efficient, and free from the pitfalls of traditional locking mechanisms. Through the works of Andrei Alexandrescu and others, the principles of lock-free programming have become more accessible to developers, leading to the creation of high-performance systems in fields ranging from databases to game engines. By leveraging atomic operations and non-blocking algorithms, developers can design software that scales with the growing demands of modern multi-core processors, all while avoiding the bottlenecks and complexities of locks.

For developers interested in mastering lock-free programming, Alexandrescu’s writings provide invaluable insights into the underlying principles and best practices for building robust, high-performance systems. While it may take time to become proficient in these techniques, the rewards of writing efficient, scalable, and deadlock-free code are well worth the effort.

##### You said:

Explaim how lock free programming works using the CAS assembly language instruction. Show an example in assembly language and then show an example in c

###### ChatGPT said:

ChatGPT

### Understanding Lock-Free Programming Using the CAS Assembly Instruction

Lock-free programming relies on atomic operations to modify shared data without requiring mutual exclusion or locks. One of the key atomic operations that forms the basis of lock-free programming is the **Compare-and-Swap (CAS)** operation. CAS allows a thread to atomically compare a value in memory with a given value and, if they are equal, replace it with a new value.

In this explanation, we'll break down how CAS works at the assembly level and then show how it can be used in C to implement lock-free algorithms.

### How CAS Works

The **Compare-and-Swap (CAS)** operation can be described as:

1. It reads a memory location.
2. It compares the value at that location with a specified expected value.
3. If the values are the same, the memory location is updated with a new value.
4. If the values are different, no update occurs, and the operation "fails" (it returns the original value).

This operation is atomic, meaning no other thread can interrupt it while it is in progress, which is essential for writing lock-free algorithms.

### CAS in Assembly Language

Let's first look at how CAS can be implemented using assembly language. On modern architectures, such as x86 or ARM, CAS instructions are provided as part of the processor's instruction set.

For example, on x86-based processors, we can use the **`CMPXCHG`** instruction, which stands for "Compare and Exchange." This instruction compares the contents of a memory location with a given value, and if they match, it replaces the memory contents with a new value.

#### Assembly Code Example (x86)

Here's an example of how you might implement CAS in assembly language:

asm

CopyEdit

`; CAS implementation in x86 assembly using CMPXCHG ; Registers: ; EAX = expected value ; EBX = new value ; ECX = address of the shared memory location  CAS:     ; Load the current value from the memory location into EAX     MOV EAX, [ECX]      ; EAX = *address      ; Compare EAX with the expected value     CMP EAX, [EDX]      ; Compare EAX with expected value (EDX)      ; If equal, replace the value with the new value in EBX     JNE CAS_DONE        ; If not equal, jump to CAS_DONE (operation fails)      ; Perform the swap     MOV [ECX], EBX      ; Update memory location with new value (EBX)  CAS_DONE:     ; Return (EAX still contains the original value)     RET`

In this example:

* `ECX` holds the address of the memory location we want to update.
* `EDX` holds the expected value (what we want to compare the memory location to).
* `EBX` holds the new value that should be written if the comparison is successful.

The `CMPXCHG` instruction atomically compares the value in `EAX` with the value at `[ECX]`. If they match, the value at `[ECX]` is replaced with the value in `EBX`. If they don't match, the instruction does nothing, and the original value at `[ECX]` is returned in `EAX`.

### CAS in C

Now, let's look at how we can use CAS in C to implement a simple lock-free counter.

#### C Code Example Using `__atomic_compare_exchange_n`

Many modern compilers, such as GCC and Clang, support built-in atomic functions for implementing CAS. In this case, we'll use the built-in atomic functions for an atomic compare-and-swap operation.

c

CopyEdit

`#include <stdio.h> #include <stdatomic.h>  atomic_int counter = 0; // Declare an atomic integer  // Lock-free increment function using CAS void lock_free_increment() {     int expected, new_value;     do {         expected = atomic_load(&counter);               // Load the current value         new_value = expected + 1;                       // Calculate the new value     } while (!atomic_compare_exchange_weak(&counter, &expected, new_value)); // Attempt to update the counter }  int main() {     // Perform lock-free increments     for (int i = 0; i < 1000; ++i) {         lock_free_increment();     }     printf("Final counter value: %d\n", atomic_load(&counter));     return 0; }`

### Explanation of the C Code:

1. **Atomic Variables**: `atomic_int counter` is used to define an atomic integer. This ensures that the variable can be safely modified by multiple threads without requiring locks.

2. **CAS Loop**: In the `lock_free_increment` function, we implement a simple increment using CAS:

   * `atomic_load(&counter)` retrieves the current value of `counter`.
   * We calculate the `new_value` by adding `1` to `expected`.
   * `atomic_compare_exchange_weak` attempts to atomically replace the value of `counter` with `new_value` only if it is equal to the `expected` value. This ensures that the counter is only updated if no other thread has modified it in the meantime.

3. **Looping**: If the `atomic_compare_exchange_weak` fails (i.e., another thread has updated the counter in the meantime), the function retries by reloading the `counter` and attempting the exchange again. This loop is known as a "busy-wait" or "retry" loop and ensures that the operation is lock-free.

### Key Points

* The CAS instruction operates atomically, ensuring that no other thread can interrupt the comparison and update process.
* The C code example uses atomic functions (`atomic_load` and `atomic_compare_exchange_weak`) to achieve the same effect as the assembly version but in a high-level language.
* The loop in the C code exemplifies the "retry until successful" approach, which is common in lock-free algorithms. If two threads try to increment the counter simultaneously, one will fail the CAS and retry.

### Conclusion

CAS is the cornerstone of many lock-free algorithms and data structures. At the assembly level, it leverages atomic operations to ensure consistency and correctness without locking. In C, the same atomic operations can be used to implement complex lock-free behaviors such as the lock-free counter example shown above.

While using CAS in low-level assembly offers direct control over atomicity, modern high-level languages and compilers abstract this complexity away, providing easier-to-use atomic operations that are still efficient and scalable for concurrent programming.

You’ve hit the Free plan limit for GPT-4o.

Responses will use another model until your limit resets after 7:35 AM.

Get Plus

ChatGPT can make mistakes. Check important info.

?
