---
title: Rust Diesel ORM In a Nutshell
description: Rust ORM
slug: rust-diesel-orm-in-a-nutshell
date: 2017-06-18
image: post/Articles/IMAGES/rust.png
categories:
  - Rust
  - Diesel
  - Database
  - ORM
  - SQL
tags:
  - Rust
  - Diesel
  - Database
  - Orm
draft: false
weight: 547
lastmod: 2025-03-06T02:38:55.278Z
---
# Rust Diesel ORM In a Nutshell

So, you’ve been messing around with Rust, and you’ve realized you need a database. You start Googling, and BOOM—you stumble upon Diesel, Rust’s fancy-pants ORM (Object-Relational Mapper). But what exactly is it, and why should you care?

<!-- 
Well, my friend, buckle up because we’re about to take a ride through Diesel-land, where SQL queries meet Rust safety, and you actually enjoy working with databases instead of crying yourself to sleep. -->

***

## Why Diesel?

Rust is all about safety and performance, right? Diesel embraces that philosophy by making SQL interactions type-safe. No more “Oops, I sent a string where an integer was expected” kind of bugs.

With Diesel, your database interactions are checked at compile time, meaning fewer runtime surprises and more confidence in your code. Plus, it’s built for speed. Because who likes slow queries?

***

## Setting Up Diesel

### 1. Install Diesel CLI

First things first, install the Diesel CLI. You’ll need `cargo` and some patience:

```sh
cargo install diesel_cli --no-default-features --features sqlite
```

You can swap `sqlite` with `postgres` or `mysql` depending on your database of choice.

### 2. Initialize Diesel

Run the following in your Rust project’s root:

```sh
diesel setup
```

This sets up a `diesel.toml` configuration file and a migrations directory. If you see errors, you probably forgot to install the database you’re using. Go fix that first!

### 3. Add Diesel to `Cargo.toml`

```toml
[dependencies]
diesel = { version = "2.0", features = ["sqlite"] }
serde = { version = "1.0", features = ["derive"] }
```

Again, swap out `sqlite` for `postgres` or `mysql` if needed.

***

## Defining a Schema

Diesel uses `diesel print-schema` to generate a Rust representation of your database schema. Run:

```sh
diesel print-schema > src/schema.rs
```

Now, you’ll have a `schema.rs` file that looks something like this:

```rust
// src/schema.rs

// Auto-generated by Diesel. DO NOT EDIT!
table! {
    users (id) {
        id -> Integer,
        name -> Text,
        email -> Text,
    }
}
```

Boom! Your database schema is now part of your Rust code. Nice and safe.

***

## Creating Models

Next, define your Rust models. This is where things start getting fun.

```rust
// src/models.rs
use diesel::prelude::*;

#[derive(Queryable)]
pub struct User {
    pub id: i32,
    pub name: String,
    pub email: String,
}
```

This `User` struct now matches the `users` table. Diesel’s magic ensures that everything is type-safe.

***

## Running Queries

### Inserting Data

Adding a new user is as easy as:

```rust
use diesel::prelude::*;
use diesel::sqlite::SqliteConnection;
use crate::schema::users;
use crate::models::User;

pub fn create_user(conn: &SqliteConnection, name: &str, email: &str) -> User {
    use crate::schema::users::dsl::*;

    let new_user = (name.eq(name), email.eq(email));
    
    diesel::insert_into(users)
        .values(&new_user)
        .execute(conn)
        .expect("Error saving new user");
}
```

### Fetching Data

Want to get all users? Easy:

```rust
pub fn get_users(conn: &SqliteConnection) -> Vec<User> {
    use crate::schema::users::dsl::*;

    users.load::<User>(conn).expect("Error loading users")
}
```

Diesel handles all the boilerplate, and you get your results in a nice, safe `Vec<User>`.

***

## Diesel vs Other ORMs

Here’s a quick comparison between Diesel and some popular ORMs:

| Feature             | Diesel | SQLx  | SeaORM |
| ------------------- | ------ | ----- | ------ |
| Compile-time safety | ✅ Yes  | ❌ No  | ❌ No   |
| Async support       | ❌ No   | ✅ Yes | ✅ Yes  |
| Raw SQL support     | ✅ Yes  | ✅ Yes | ✅ Yes  |
| Migration support   | ✅ Yes  | ✅ Yes | ✅ Yes  |
| Learning curve      | Medium | Easy  | Hard   |

As you can see, Diesel shines in compile-time safety, but it’s not async-friendly. If you need async, SQLx or SeaORM might be better choices.

***

<!-- ## Conclusion

Diesel is a fantastic ORM for Rust if you value type safety and compile-time checks. It forces you to write solid, SQL-backed Rust code without any runtime surprises.

The trade-off? A slightly higher learning curve and no async support. But hey, nothing good comes easy, right?

So, if you love Rust and databases and want the best of both worlds, Diesel is your guy. Just don’t expect it to make your coffee in the morning. -->

***

## Key Ideas

| Concept    | Summary                                                            |
| ---------- | ------------------------------------------------------------------ |
| Diesel ORM | Rust’s type-safe, compile-time-checked database ORM                |
| Setup      | Install Diesel CLI, initialize, and configure Cargo dependencies   |
| Schema     | `diesel print-schema` generates Rust code for your database schema |
| Models     | Define Rust structs that match your DB tables                      |
| Queries    | Diesel makes inserts, updates, and selects type-safe and intuitive |
| Comparison | Diesel is safer but lacks async, unlike SQLx or SeaORM             |

***

## References

* [Diesel Official Docs](https://diesel.rs/)
* [Rust Book](https://doc.rust-lang.org/book/)
* [SQLx](https://github.com/launchbadge/sqlx)
* [SeaORM](https://www.sea-ql.org/SeaORM/)
